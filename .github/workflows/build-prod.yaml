name: Build PROD

on:
  workflow_run:
    workflows: ["Build ISO"]
    types:
      - completed

jobs:
  build:
    name: Build image
    environment: prod
    runs-on: ubuntu-latest

    concurrency:
      group: public
      cancel-in-progress: false

    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download ISO artifact from build-iso workflow
        uses: dawidd6/action-download-artifact@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workflow: build-iso.yaml
          run_id: ${{ github.event.client_payload.run_id }}
          name: ${{ github.event.client_payload.iso_artifact_name }}
          path: ./iso

      - name: Prepare ISO path for Packer
        id: iso_path
        shell: bash
        run: |
          ISO_FILE=$(ls -1 ./iso/*.iso | head -n1)
          ISO_FULL_PATH=$(realpath "$ISO_FILE")
          echo "iso_path=$ISO_FULL_PATH" >> $GITHUB_OUTPUT
          echo "Using ISO: $ISO_FULL_PATH"
          ls -lh "$ISO_FULL_PATH"

      - name: Determine available location for cx23 servers
        id: location
        shell: bash
        env:
          HCLOUD_TOKEN: ${{ secrets.HCLOUD_TOKEN }}
        run: |
          echo "Querying Hetzner API for cx23 server availability..."
          
          # Get server type details
          SERVER_TYPE_DATA=$(curl -s -H "Authorization: Bearer $HCLOUD_TOKEN" \
            "https://api.hetzner.cloud/v1/server_types?name=cx23")
          
          # Extract available locations for cx23
          AVAILABLE_LOCATIONS=$(echo "$SERVER_TYPE_DATA" | jq -r '.server_types[0].prices[] | select(.location != null) | .location' | sort)
          
          if [ -z "$AVAILABLE_LOCATIONS" ]; then
            echo "Warning: Could not determine cx23 availability, falling back to default location (nbg1)"
            echo "location=nbg1" >> $GITHUB_OUTPUT
          else
            # Prefer locations in this order: nbg1, fsn1, hel1, ash, hil
            PREFERRED_ORDER=("nbg1" "fsn1" "hel1" "ash" "hil")
            SELECTED_LOCATION=""
            
            for preferred in "${PREFERRED_ORDER[@]}"; do
              if echo "$AVAILABLE_LOCATIONS" | grep -q "^${preferred}$"; then
                SELECTED_LOCATION="$preferred"
                break
              fi
            done
            
            # If no preferred location found, use first available
            if [ -z "$SELECTED_LOCATION" ]; then
              SELECTED_LOCATION=$(echo "$AVAILABLE_LOCATIONS" | head -n1)
            fi
            
            echo "Available locations for cx23:"
            echo "$AVAILABLE_LOCATIONS"
            echo ""
            echo "Selected location: $SELECTED_LOCATION"
            echo "location=$SELECTED_LOCATION" >> $GITHUB_OUTPUT
          fi

      - name: Build image
        uses: ./.github/actions/build-image
        with:
          template: vyos.pkr.hcl
          token: ${{ secrets.HCLOUD_TOKEN }}
          build-identifier: github-actions-${{ github.repository_id }}-${{ github.run_number }}
          iso-path: ${{ steps.iso_path.outputs.iso_path }}
          server-location: ${{ steps.location.outputs.location }}
          trigger-payload: ${{ toJson(github.event.client_payload) }}

  cleanup:
    name: Clean up resources from failed run
    environment: public
    runs-on: ubuntu-latest

    needs: build
    if: failure()

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Clean up resources after error
        uses: ./.github/actions/cleanup
        with:
          token: ${{ secrets.HCLOUD_TOKEN }}
          build-identifier: github-actions-${{ github.repository_id }}-${{ github.run_number }}

  expire:
    name: Clean up tangling images in production
    environment: public
    runs-on: ubuntu-latest

    if: github.event.schedule == '0 0 * * 0'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Clean up tangling images
        uses: ./.github/actions/cleanup-images
        with:
          token: ${{ secrets.HCLOUD_TOKEN }}
