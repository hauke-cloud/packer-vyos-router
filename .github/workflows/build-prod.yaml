name: Build PROD

on:
  workflow_run:
    workflows: ["Build ISO"]
    types:
      - completed

jobs:
  build:
    name: Build image
    environment: prod
    runs-on: ubuntu-latest

    concurrency:
      group: public
      cancel-in-progress: false

    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get workflow run info
        id: workflow_info
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.payload.workflow_run.id
            });

            if (artifacts.data.artifacts.length === 0) {
              core.setFailed('No artifacts found');
              return;
            }

            const artifact = artifacts.data.artifacts[0];
            core.setOutput('artifact_name', artifact.name);
            core.setOutput('run_id', context.payload.workflow_run.id);
            console.log(`Found artifact: ${artifact.name}`);

      - name: Download ISO artifact from build-iso workflow
        uses: dawidd6/action-download-artifact@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workflow: build-iso.yaml
          run_id: ${{ steps.workflow_info.outputs.run_id }}
          name: ${{ steps.workflow_info.outputs.artifact_name }}
          path: ./iso

      - name: Prepare ISO path for Packer
        id: iso_path
        shell: bash
        run: |
          # The artifact extracts to iso/<artifact-name>/<iso-file>.iso
          ISO_FILE=$(find ./iso -name "*.iso" -type f | head -n1)
          if [ -z "$ISO_FILE" ]; then
            echo "ERROR: No ISO file found in ./iso directory"
            ls -R ./iso
            exit 1
          fi
          ISO_FULL_PATH=$(realpath "$ISO_FILE")
          echo "iso_path=$ISO_FULL_PATH" >> $GITHUB_OUTPUT
          echo "Using ISO: $ISO_FULL_PATH"
          ls -lh "$ISO_FULL_PATH"

          # Read customization version from metadata file
          VERSION_FILE=$(find ./iso -name "customization-version.txt" -type f | head -n1)
          if [ -n "$VERSION_FILE" ] && [ -f "$VERSION_FILE" ]; then
            CUSTOMIZATION_VERSION=$(cat "$VERSION_FILE")
            echo "vyos_customization_version=$CUSTOMIZATION_VERSION" >> $GITHUB_OUTPUT
            echo "Found customization version: $CUSTOMIZATION_VERSION"
          else
            echo "WARNING: No customization-version.txt found, version will not be included in labels"
          fi

          # Read release version from metadata file (for release builds)
          RELEASE_FILE=$(find ./iso -name "release-version.txt" -type f | head -n1)
          if [ -n "$RELEASE_FILE" ] && [ -f "$RELEASE_FILE" ]; then
            RELEASE_VERSION=$(cat "$RELEASE_FILE")
            echo "release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
            echo "Found release version: $RELEASE_VERSION"
            echo "This is a RELEASE build - snapshot will be protected"
          else
            echo "This is a regular (non-release) build"
          fi

      - name: Determine available location and server type
        id: location
        uses: ./.github/actions/find-server-location
        with:
          token: ${{ secrets.HCLOUD_TOKEN }}
          preferred-locations: "nbg1,fsn1,hel1,ash,hil"

      - name: Build image
        uses: ./.github/actions/build-image
        with:
          template: vyos.pkr.hcl
          token: ${{ secrets.HCLOUD_TOKEN }}
          build-identifier: github-actions-${{ github.repository_id }}-${{ github.run_number }}
          iso-path: ${{ steps.iso_path.outputs.iso_path }}
          server-location: ${{ steps.location.outputs.location }}
          server-type: ${{ steps.location.outputs.server-type }}
          vyos-customization-version: ${{ steps.iso_path.outputs.vyos_customization_version }}
          release-version: ${{ steps.iso_path.outputs.release_version }}

  cleanup:
    name: Clean up resources from failed run
    environment: public
    runs-on: ubuntu-latest

    needs: build
    if: failure()

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Clean up resources after error
        uses: ./.github/actions/cleanup
        with:
          token: ${{ secrets.HCLOUD_TOKEN }}
          build-identifier: github-actions-${{ github.repository_id }}-${{ github.run_number }}

  expire:
    name: Clean up tangling images in production
    environment: public
    runs-on: ubuntu-latest

    if: github.event.schedule == '0 0 * * 0'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Clean up tangling images
        uses: ./.github/actions/cleanup-images
        with:
          token: ${{ secrets.HCLOUD_TOKEN }}
